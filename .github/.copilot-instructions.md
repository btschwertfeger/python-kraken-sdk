# Python Kraken SDK - Copilot Instructions

## Project Overview

This is the **python-kraken-sdk** - a high-performance REST and WebSocket API
client for Kraken Crypto Asset Exchange supporting both Spot and Futures
trading. The SDK prioritizes performance, maintainability, reliability,
modularization, and code reuse.

## Core Principles

### Code Quality Standards

- **Performance First**: Optimize for speed and memory efficiency
- **Maintainability**: Write clean, readable, self-documenting code
- **Reliability**: Implement robust error handling and comprehensive testing
- **Modularization**: Favor composition over inheritance, create reusable
  components
- **DRY Principle**: Eliminate code duplication through shared utilities and
  base classes

### Comment Philosophy

- **Minimal Comments**: Code should be self-explanatory through clear naming and
  structure
- **Only When Necessary**: Add comments only for non-obvious business logic,
  complex algorithms, or API-specific quirks
- **No Obvious Comments**: Avoid stating what the code clearly does
- **Focus on Why**: When commenting, explain the reasoning, not the mechanics

## Project Structure

```
src/kraken/
├── __init__.py                # Main package exports
├── cli.py                     # Command-line interface
├── base_api/                  # Core base classes and utilities
│   └── __init__.py            # SpotClient, FuturesClient, SpotAsyncClient, FuturesAsyncClient
├── exceptions/                # Custom exception classes
│   └── __init__.py            # KrakenException hierarchy
├── utils/                     # Shared utilities and helpers
├── spot/                      # Spot trading API
│   ├── __init__.py            # Spot client exports
│   ├── market.py              # Market data client
│   ├── trade.py               # Trading operations client
│   ├── user.py                # User account client
│   ├── funding.py             # Funding operations client
│   ├── earn.py                # Earn/staking client
│   ├── orderbook.py           # Order book client
│   ├── ws_client.py           # WebSocket client implementation
│   └── websocket/             # WebSocket infrastructure
│       ├── __init__.py        # SpotWSClientBase
│       └── connectors.py      # Connection management
└── futures/                   # Futures trading API
    ├── __init__.py            # Futures client exports
    ├── market.py              # Futures market data
    ├── trade.py               # Futures trading
    ├── user.py                # Futures user account
    ├── funding.py             # Futures funding
    ├── ws_client.py           # Futures WebSocket client
    └── websocket/             # Futures WebSocket infrastructure
```

## Architecture Patterns

### Client Hierarchy

- **Base Classes**: `SpotClient`, `FuturesClient` (REST), `SpotAsyncClient`,
  `FuturesAsyncClient` (async REST)
- **Specialized Clients**: Market, Trade, User, Funding, Earn (inherit from
  base)
- **WebSocket Clients**: `SpotWSClient`, `FuturesWSClient` (extend async base
  classes)

### Key Design Patterns

- **Composition over Inheritance**: Favor utility functions and mixins
- **Async/Await**: All WebSocket and async operations use proper async patterns
- **Context Managers**: Support `async with` for resource management
- **Type Hints**: Comprehensive typing with `typing` and `TYPE_CHECKING`
- **Error Handling**: Custom exception hierarchy with specific error types

## Development Guidelines

### Code Style

- **Python 3.11+**: Use modern Python features and syntax
- **Type Annotations**: All functions must have complete type hints
- **Docstrings**: Use Google-style docstrings for public APIs
- **Naming**: Clear, descriptive names that eliminate need for comments

### Performance Optimization

- **Async Operations**: Use async/await for I/O operations
- **Connection Pooling**: Reuse HTTP connections where possible
- **Memory Efficiency**: Avoid unnecessary object creation in hot paths
- **Caching**: Use `@lru_cache` for expensive computations
- **Lazy Loading**: Initialize resources only when needed

### Error Handling

- **Custom Exceptions**: Use specific exception types from `kraken.exceptions`
- **Graceful Degradation**: Handle network failures and API errors robustly
- **Retry Logic**: Implement exponential backoff for transient failures
- **Logging**: Use structured logging with appropriate levels

### Testing Standards

- **Comprehensive Coverage**: Aim for high test coverage
- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test API interactions (with mocking when needed)
- **Class-Based Organization**: Use pytest classes with shared fixtures and
  constants
- **Helper Methods**: Create reusable assertion helpers to eliminate duplication

### WebSocket Patterns

- **Connection Management**: Proper connection lifecycle handling
- **Subscription Management**: Track active subscriptions
- **Message Routing**: Efficient message dispatch to handlers
- **Reconnection Logic**: Automatic reconnection with backoff

## Code Generation Guidelines

### When Creating New Features

1. **Extend Existing Patterns**: Follow established client patterns
2. **Reuse Base Classes**: Inherit from appropriate base classes
3. **Share Common Logic**: Extract reusable components
4. **Maintain API Consistency**: Follow existing parameter and return patterns
5. **Add Comprehensive Tests**: Include unit and integration tests

### When Refactoring

1. **Preserve Public APIs**: Maintain backward compatibility
2. **Improve Performance**: Look for optimization opportunities
3. **Reduce Complexity**: Simplify complex methods through decomposition
4. **Enhance Type Safety**: Add or improve type annotations
5. **Update Tests**: Ensure tests reflect changes

### Specific Preferences

- **Constants**: Use UPPER_CASE for module-level constants
- **Private Methods**: Use single underscore prefix for internal methods
- **Property Methods**: Use `@property` for computed attributes
- **Context Managers**: Implement `__enter__`/`__exit__` or
  `__aenter__`/`__aexit__` when managing resources

## API Design Philosophy

- **Pythonic Interface**: Feel natural to Python developers
- **Sensible Defaults**: Minimize required parameters
- **Flexibility**: Support both high-level convenience and low-level control
- **Performance**: Optimize for common use cases
- **Documentation**: Self-documenting through clear parameter names and types

## Testing Philosophy

- **Fast Feedback**: Tests should run quickly
- **Reliable**: Tests should not be flaky
- **Isolated**: Each test should be independent
- **Realistic**: Test real scenarios, not just edge cases
- **Maintainable**: Tests should be easy to understand and modify

Remember: The goal is to create a professional, high-performance SDK that
developers love to use. Prioritize clarity, performance, and reliability in all
code contributions.
